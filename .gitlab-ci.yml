image:
  name: hashicorp/terraform:1.9.5
  entrypoint:
    - '/usr/bin/env'
    - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'

variables:
    IMAGE_NAME: strelchenk0nazar/tgbot_deploy
    IMAGE_TAG: tgbot_deploy
    AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY}
    AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
    AWS_DEFAULT_REGION: "us-east-1"

stages:
  - build_docker_image
  - terraform_validate
  - terraform_plan
  - terraform_apply
  - terraform_destroy
  # - ansible_deploy

# Етап збірки Docker-образу
build_docker_image:
  stage: build_docker_image
  image: docker:latest
  services:
    - docker:20.10.16-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
  script:
    - docker build -t $IMAGE_NAME:$IMAGE_TAG .
    - docker push $IMAGE_NAME:$IMAGE_TAG


before_script:
  - export AWS_ACCESS_KEY=${AWS_ACCESS_KEY_ID}
  - export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
  - cd terraform
  - rm -rf .terraform
  - terraform --version
  - terraform init

# Етап ініціалізації та виконання Terraform
terraform_validate:
  stage: terraform_validate
  # image: hashicorp/terraform:latest  # Використовуємо Alpine для shell команд
  script:
    - terraform validate

terraform_plan:
  stage: terraform_plan
  script: 
    - terraform plan -out "planfile"
    - ls -la
  dependencies:
    - terraform_validate  
  artifacts:
    paths:
      - terraform/planfile

terraform_apply: 
  stage: terraform_apply
  dependencies:
    - terraform_plan
  script: 
    - ls -la
    - terraform apply -input=false "planfile"
  when: manual

terraform_destroy:
  stage: terraform_destroy
  script: 
  - terraform destroy -auto-approve
  when: manual

# Етап розгортання з використанням Ansible
# ansible_deploy:
#   stage: ansible_deploy
#   image: williamyeh/ansible:alpine3
#   script:
#     - cd ansible
#     - ansible-playbook -i inventory.ini deploy.yml
#   only:
#     - main
#   variables:
#     ANSIBLE_HOST_KEY_CHECKING: "False"
